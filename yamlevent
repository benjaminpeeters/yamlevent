#!/bin/bash

# yamlevent - Unified YAML event management tool
#
# PURPOSE: Create new YAML events or add content to existing events
#
# MODES:
#   --new      Create new event (equivalent to yamlevent-newlabel)
#   --add      Add content to existing event (equivalent to yamlevent-addcontent)
#
# NEW EVENT MODE (--new):
#   REQUIRED: <file> <line_number> <iso> <date> <title> --description --source
#   OPTIONAL: --cause, --impact, --demo
#
# ADD CONTENT MODE (--add):
#   REQUIRED: <file> <label> --description --source  
#   OPTIONAL: --cause, --impact, --demo
#
# For detailed documentation, see: yamlevent --help

yamlevent() {
    # Check for mode flags first
    local mode=""
    if [[ "$1" == "--new" ]]; then
        mode="new"
        shift
    elif [[ "$1" == "--add" ]]; then
        mode="add"
        shift
    elif [[ "$1" == "--help" || "$1" == "-h" ]]; then
        _show_help
        return 0
    elif [[ "$1" == "--version" ]]; then
        echo "yamlevent version 1.0.0"
        return 0
    fi
    
    # If no mode specified, try to infer from arguments
    if [[ -z "$mode" ]]; then
        if [[ $# -ge 5 && "$2" =~ ^[0-9]+$ ]]; then
            mode="new"
        elif [[ $# -ge 2 ]]; then
            mode="add"
        else
            echo "ERROR: Could not determine mode. Use --new or --add" >&2
            echo "       Run 'yamlevent --help' for usage information" >&2
            return 1
        fi
    fi
    
    # Dispatch to appropriate function
    case "$mode" in
        "new")
            _yamlevent_new "$@"
            ;;
        "add")
            _yamlevent_add "$@"
            ;;
        *)
            echo "ERROR: Invalid mode '$mode'" >&2
            return 1
            ;;
    esac
}

# Show comprehensive help
_show_help() {
    cat << 'EOF'
yamlevent - Unified YAML event management tool

USAGE:
  yamlevent --new <file> <line> <iso> <date> <title> --description DESC --source SOURCE
  yamlevent --add <file> <label> --description DESC --source SOURCE

MODES:
  --new    Create new event entry (equivalent to yamlevent-newlabel)
  --add    Add content to existing event (equivalent to yamlevent-addcontent)

ARGUMENTS:
  REQUIRED (--new): file, line_number, iso, date, title, --description, --source  
  REQUIRED (--add): file, label, --description, --source
  OPTIONAL (both):  --cause, --impact, --demo

SOURCE VALIDATION (must have one of):
  ✅ 1+ path:      --source "Name|path:~/file.txt"
  ✅ 2+ URLs:      --source "Name|url:https://url1|url:https://url2"
  ✅ 2 sources:    --source "Name1|url:https://url1" --source "Name2|url:https://url2"
  ✅ URL + path:   --source "Name|url:https://url|path:~/file.txt"
  ❌ 1 URL only:   --source "Name|url:https://single" (INVALID)

FORMATS:
  DATES: 1929, 1929-10, 1929-10-24, 1929-Q4, "1929 to 1933"
  LISTS: Use | separator: --description "Item1|Item2|Item3"
  LABEL: underscore_separated (e.g., "usa_1929_10_crash")

EXAMPLES:

  # Create new event
  yamlevent --new events.md 10 USA 1929-10 "Stock Market Crash" \
    --description "Black Tuesday triggers financial crisis|Market loses 25%" \
    --cause "Excessive speculation|Margin buying overextension" \
    --impact "Wealth destruction|Investor confidence collapses" \
    --demo "Shows market psychology effects|Demonstrates leverage dangers" \
    --source "Federal Reserve|url:https://fraser.stlouisfed.org|url:https://federalreservehistory.org"

  # Add content to existing event  
  yamlevent --add events.md "usa_1929_10_stock_market_crash" \
    --description "Banking system collapses|Bank runs spread nationwide" \
    --cause "Overleveraged institutions|Loss of public confidence" \
    --impact "9,000 banks fail by 1933|Savings accounts wiped out" \
    --demo "Shows banking interconnectedness|Reveals deposit insurance need" \
    --source "FDIC Historical Archives|path:~/research/bank_failures_1929.txt"

For more examples and detailed documentation, see function headers in this file.
EOF
}

# NEW EVENT MODE - Create new YAML event entries
_yamlevent_new() {
    local usage="USAGE: yamlevent --new <file> <line> <iso> <date> <title> --description DESC --source SOURCE

REQUIRED: file, line_number, iso, date, title, --description, --source
OPTIONAL: --cause, --impact, --demo

SOURCE VALIDATION (must have one):
✅ 1+ path: --source \"Name|path:~/file.txt\"
✅ 2+ URLs: --source \"Name|url:https://url1|url:https://url2\"
✅ 2 sources: --source \"Name1|url:https://url1\" --source \"Name2|url:https://url2\"
✅ Mixed:   --source \"Name|url:https://url|path:~/file.txt\"
❌ 1 URL:   --source \"Name|url:https://single\" (FAILS)

LISTS: Use | separator: --description \"Item1|Item2\"
DATES: 1929, 1929-10, 1929-10-24, \"1929 to 1933\"

EXAMPLE:
yamlevent --new events.md 10 USA 1929-10 \"Stock Crash\" \\
  --description \"Black Tuesday crisis\" \\
  --source \"Fed|url:https://url1|url:https://url2\""
    
    # Validate minimum arguments
    if [[ $# -lt 5 ]]; then
        echo "ERROR: Missing required arguments" >&2
        echo "$usage" >&2
        return 1
    fi
    
    local file="$1"
    local line_number="$2"
    local iso="$3"
    local date="$4"
    local title="$5"
    shift 5
    
    # Validate file and line number
    if [[ ! "$line_number" =~ ^[0-9]+$ ]] || [[ "$line_number" -lt 1 ]]; then
        echo "ERROR: line_number must be a positive integer, got: '$line_number'" >&2
        return 1
    fi
    
    # Initialize variables
    local description="" cause="" impact="" demo=""
    local -a sources=()
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --description)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --description requires a value" >&2
                    return 1
                fi
                description="$2"; shift 2 ;;
            --cause)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --cause requires a value" >&2
                    return 1
                fi
                cause="$2"; shift 2 ;;
            --impact)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --impact requires a value" >&2
                    return 1
                fi
                impact="$2"; shift 2 ;;
            --demo)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --demo requires a value" >&2
                    return 1
                fi
                demo="$2"; shift 2 ;;
            --source)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --source requires a value" >&2
                    return 1
                fi
                sources+=("$2"); shift 2 ;;
            *)
                echo "ERROR: Unknown option '$1'" >&2
                echo "$usage" >&2
                return 1 ;;
        esac
    done
    
    # Validate required fields
    if [[ -z "$description" ]]; then
        echo "ERROR: --description is required (provide event description)" >&2
        return 1
    fi
    
    if [[ ${#sources[@]} -eq 0 ]]; then
        echo "ERROR: At least one --source is required" >&2
        return 1
    fi
    
    # Validate date format
    if ! _validate_date_format "$date"; then
        echo "ERROR: Invalid date format '$date'" >&2
        echo "       Supported formats: YYYY, YYYY-MM, YYYY-MM-DD, YYYY-Q[1-4], 'YYYY to YYYY' periods" >&2
        echo "       Examples: 1933, 1933-04, 1933-04-05, 1933-Q2, '1929 to 1939'" >&2
        return 1
    fi
    
    # Validate ISO code (basic check)
    if [[ ! "$iso" =~ ^[A-Z]{3}$ ]]; then
        echo "ERROR: ISO code must be 3 uppercase letters, got: '$iso'" >&2
        echo "       Examples: USA, GBR, CHE, DEU, FRA" >&2
        return 1
    fi
    
    # Validate sources
    for source_spec in "${sources[@]}"; do
        if ! _validate_source_spec "$source_spec"; then
            return 1
        fi
    done
    
    # Validate overall source requirements
    if ! _validate_overall_source_requirements; then
        return 1
    fi
    
    # Generate label
    local label="$(_generate_label "$iso" "$date" "$title")"
    
    # Build YAML content - label + metadata + content array + ONE trailing blank line
    local content="${label}:
    date: ${date}
    iso: ${iso}
    title: ${title}
    content:
      - "
    
    # Add description field with list support (first field)
    _add_field_to_content_item "description" "$description" "true"
    
    # Add optional fields (not first)
    [[ -n "$cause" ]] && _add_field_to_content_item "cause" "$cause" "false"
    [[ -n "$impact" ]] && _add_field_to_content_item "impact" "$impact" "false"
    [[ -n "$demo" ]] && _add_field_to_content_item "demo" "$demo" "false"
    
    # Add sources
    _add_sources_to_content_item
    
    # ALWAYS add exactly ONE trailing blank line (label-level entry requirement)
    content+="

"
    
    # Insert into file
    local temp_file=$(/usr/bin/mktemp)
    if [[ -f "$file" ]]; then
        local file_lines=$(/usr/bin/wc -l < "$file")
        if [[ "$line_number" -gt $((file_lines + 1)) ]]; then
            echo "ERROR: line_number $line_number exceeds file length ($file_lines lines)" >&2
            /usr/bin/rm -f "$temp_file"
            return 1
        fi
        /usr/bin/head -n $((line_number - 1)) "$file" > "$temp_file"
        echo -n "$content" >> "$temp_file"
        /usr/bin/tail -n +$line_number "$file" >> "$temp_file"
    else
        echo -n "$content" > "$temp_file"
    fi
    /usr/bin/mv "$temp_file" "$file"
    
    echo "SUCCESS: Created label '$label' in $file at line $line_number"
}

# ADD CONTENT MODE - Add content to existing YAML event
_yamlevent_add() {
    local usage="USAGE: yamlevent --add <file> <label> --description DESC --source SOURCE

REQUIRED: file, label, --description, --source
OPTIONAL: --cause, --impact, --demo

LABEL: underscore_separated (e.g., \"usa_1929_10_crash\")

SOURCE VALIDATION (must have one):
✅ 1+ path: --source \"Name|path:~/file.txt\"
✅ 2+ URLs: --source \"Name|url:https://url1|url:https://url2\"
✅ 2 sources: --source \"Name1|url:https://url1\" --source \"Name2|url:https://url2\"
✅ Mixed:   --source \"Name|url:https://url|path:~/file.txt\"
❌ 1 URL:   --source \"Name|url:https://single\" (FAILS)

LISTS: Use | separator: --description \"Item1|Item2\"

EXAMPLE:
yamlevent --add events.md \"usa_1929_10_crash\" \\
  --description \"Banking crisis spreads\" \\
  --source \"Archives|url:https://url1|url:https://url2\""
    
    # Validate minimum arguments
    if [[ $# -lt 2 ]]; then
        echo "ERROR: Missing required arguments" >&2
        echo "$usage" >&2
        return 1
    fi
    
    local file="$1" label="$2"
    shift 2
    
    # Validate file exists
    if [[ ! -f "$file" ]]; then
        echo "ERROR: File does not exist: '$file'" >&2
        return 1
    fi
    
    # Validate label format (basic check)
    if [[ ! "$label" =~ ^[a-z0-9_]+$ ]]; then
        echo "ERROR: Label must be underscore-separated (lowercase, numbers, underscores only), got: '$label'" >&2
        echo "       Expected format: 'iso_date_title' (e.g., 'usa_1933_04_05_gold_reserve_act')" >&2
        return 1
    fi
    
    # Initialize variables
    local description="" cause="" impact="" demo=""
    local -a sources=()
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --description)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --description requires a value" >&2
                    return 1
                fi
                description="$2"; shift 2 ;;
            --cause)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --cause requires a value" >&2
                    return 1
                fi
                cause="$2"; shift 2 ;;
            --impact)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --impact requires a value" >&2
                    return 1
                fi
                impact="$2"; shift 2 ;;
            --demo)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --demo requires a value" >&2
                    return 1
                fi
                demo="$2"; shift 2 ;;
            --source)
                if [[ -z "$2" || "$2" == --* ]]; then
                    echo "ERROR: --source requires a value" >&2
                    return 1
                fi
                sources+=("$2"); shift 2 ;;
            *)
                echo "ERROR: Unknown option '$1'" >&2
                echo "$usage" >&2
                return 1 ;;
        esac
    done
    
    # Validate required fields
    if [[ -z "$description" ]]; then
        echo "ERROR: --description is required (provide content description)" >&2
        return 1
    fi
    
    if [[ ${#sources[@]} -eq 0 ]]; then
        echo "ERROR: At least one --source is required" >&2
        return 1
    fi
    
    # Validate sources
    for source_spec in "${sources[@]}"; do
        if ! _validate_source_spec "$source_spec"; then
            return 1
        fi
    done
    
    # Validate overall source requirements
    if ! _validate_overall_source_requirements; then
        return 1
    fi
    
    # Find label line (reliable anchor point)
    local label_line=$(/usr/bin/grep -n "^${label}:" "$file" | /usr/bin/head -1 | /usr/bin/cut -d: -f1)
    if [[ -z "$label_line" ]]; then
        echo "ERROR: Label '$label' not found in $file" >&2
        echo "       Available labels:" >&2
        /usr/bin/grep "^[a-z0-9_]*:$" "$file" | /usr/bin/head -5 | /usr/bin/sed 's/^/         /'
        local label_count=$(/usr/bin/grep -c "^[a-z0-9_]*:$" "$file")
        if [[ $label_count -gt 5 ]]; then
            echo "         ... and $((label_count - 5)) more"
        fi
        return 1
    fi
    
    # ULTRA-ROBUST: Find end boundary of this label using boundary detection
    local boundary_line
    if [[ "$file" == *.md ]]; then
        # For .md: find closing ```
        local yaml_end=$(/usr/bin/tail -n +$((label_line + 1)) "$file" | /usr/bin/grep -n '^```$' | /usr/bin/head -1 | /usr/bin/cut -d: -f1)
        if [[ -z "$yaml_end" ]]; then
            echo "ERROR: Could not find closing \`\`\` after label '$label' in markdown file" >&2
            echo "       Label found at line $label_line, but no YAML block end detected" >&2
            return 1
        fi
        boundary_line=$((label_line + yaml_end))
    else
        # For .yml: find next label or EOF
        local next_label=$(/usr/bin/tail -n +$((label_line + 1)) "$file" | /usr/bin/grep -n "^[a-z].*:$" | /usr/bin/head -1 | /usr/bin/cut -d: -f1)
        if [[ -n "$next_label" ]]; then
            boundary_line=$((label_line + next_label))
        else
            boundary_line=$(($(/usr/bin/wc -l < "$file") + 1))
        fi
    fi
    
    # Check if content array exists
    local content_array_line=$(/usr/bin/sed -n "${label_line},$((boundary_line - 1))p" "$file" | /usr/bin/grep -n "^    content:$" | /usr/bin/cut -d: -f1)
    if [[ -z "$content_array_line" ]]; then
        echo "ERROR: Label '$label' found but contains no 'content:' array" >&2
        echo "       This label may have been created incorrectly or corrupted" >&2
        echo "       Expected 'content:' array created by yamlevent --new" >&2
        return 1
    fi
    
    # Build new content array item
    local new_content="      - "
    
    # Add description field with list support (first field)
    _add_field_to_new_content_item "description" "$description" "true"
    
    # Add optional fields (not first)
    [[ -n "$cause" ]] && _add_field_to_new_content_item "cause" "$cause" "false"
    [[ -n "$impact" ]] && _add_field_to_new_content_item "impact" "$impact" "false"
    [[ -n "$demo" ]] && _add_field_to_new_content_item "demo" "$demo" "false"
    
    # Add sources
    _add_sources_to_new_content_item
    
    # ULTRA-SIMPLE: Insert new content before the existing trailing blank line
    local temp_file=$(/usr/bin/mktemp)
    
    # Find the trailing blank line (should be line before boundary)
    local blank_line=$((boundary_line - 1))
    
    # Verify the blank line exists (safety check)
    local blank_line_content=$(/usr/bin/sed -n "${blank_line}p" "$file")
    if [[ -n "$blank_line_content" ]]; then
        echo "WARNING: Expected blank line at position $blank_line, but found content" >&2
        echo "         This may indicate the label structure is not standard" >&2
        echo "         Content: '$blank_line_content'" >&2
        # Try to find a better insertion point
        for ((i = boundary_line - 1; i >= label_line; i--)); do
            local line_content=$(/usr/bin/sed -n "${i}p" "$file")
            if [[ -z "$line_content" ]]; then
                blank_line=$i
                break
            fi
        done
    fi
    
    # Insert new content before the blank line, preserving it
    if ! /usr/bin/head -n $((blank_line - 1)) "$file" > "$temp_file"; then
        echo "ERROR: Failed to read file content before insertion point" >&2
        /usr/bin/rm -f "$temp_file"
        return 1
    fi
    
    echo "$new_content" >> "$temp_file"
    
    if ! /usr/bin/tail -n +$blank_line "$file" >> "$temp_file"; then
        echo "ERROR: Failed to read file content after insertion point" >&2
        /usr/bin/rm -f "$temp_file"
        return 1
    fi
    
    if ! /usr/bin/mv "$temp_file" "$file"; then
        echo "ERROR: Failed to update file '$file'" >&2
        return 1
    fi
    
    echo "SUCCESS: Added content item to label '$label' in $file"
}

# Validate a single source specification
_validate_source_spec() {
    local spec="$1"
    
    # Extract citation (everything before first |)
    local citation="${spec%%|*}"
    if [[ -z "$citation" ]]; then
        echo "ERROR: Source citation cannot be empty in '$spec'" >&2
        echo "       Expected format: 'Citation|url:URL|path:PATH'" >&2
        return 1
    fi
    
    # Get the rest after citation
    local rest="${spec#*|}"
    if [[ "$rest" == "$spec" ]]; then
        echo "ERROR: Source must have at least one url: or path: component in '$spec'" >&2
        echo "       Expected format: 'Citation|url:URL|path:PATH'" >&2
        return 1
    fi
    
    # Split by | and validate each component
    local has_url=false has_path=false
    local component
    
    # Process each component after the citation
    while [[ -n "$rest" ]]; do
        if [[ "$rest" == *"|"* ]]; then
            component="${rest%%|*}"
            rest="${rest#*|}"
        else
            component="$rest"
            rest=""
        fi
        
        if [[ "$component" == url:* ]]; then
            has_url=true
            local url="${component#url:}"
            if [[ -z "$url" ]]; then
                echo "ERROR: Empty URL in source '$spec'" >&2
                return 1
            fi
            if ! [[ "$url" =~ ^https:// ]]; then
                echo "ERROR: URL must start with 'https://', got '$url' in source '$spec'" >&2
                return 1
            fi
        elif [[ "$component" == path:* ]]; then
            has_path=true
            local path="${component#path:}"
            if [[ -z "$path" ]]; then
                echo "ERROR: Empty path in source '$spec'" >&2
                return 1
            fi
            local expanded_path="${path/#\~/$HOME}"
            if [[ ! -f "$expanded_path" ]]; then
                echo "ERROR: Local file does not exist: '$path'" >&2
                echo "       Expanded path: '$expanded_path'" >&2
                return 1
            fi
        else
            echo "ERROR: Invalid source component '$component' in '$spec'" >&2
            echo "       Expected format: 'Citation|url:URL|path:PATH'" >&2
            return 1
        fi
    done
    
    if [[ "$has_url" == false && "$has_path" == false ]]; then
        echo "ERROR: Source must have at least one url: or path: component in '$spec'" >&2
        return 1
    fi
    
    return 0
}

# Validate overall source requirements across all sources
_validate_overall_source_requirements() {
    local url_count=0 path_count=0
    
    # Count total URLs and paths across all sources
    for spec in "${sources[@]}"; do
        local rest="${spec#*|}"
        
        # Count url: and path: components
        local temp_rest="$rest"
        while [[ -n "$temp_rest" ]]; do
            local component
            if [[ "$temp_rest" == *"|"* ]]; then
                component="${temp_rest%%|*}"
                temp_rest="${temp_rest#*|}"
            else
                component="$temp_rest"
                temp_rest=""
            fi
            
            if [[ "$component" == url:* ]]; then
                ((url_count++))
            elif [[ "$component" == path:* ]]; then
                ((path_count++))
            fi
        done
    done
    
    # Check requirements: 
    # - At least 1 path (sufficient on its own), OR
    # - At least 2 URLs, OR  
    # - At least 1 URL + 1 path
    if [[ $path_count -gt 0 ]]; then
        # At least one path - this is always sufficient
        return 0
    elif [[ $url_count -ge 2 ]]; then
        # At least 2 URLs - this is sufficient
        return 0
    else
        # Not enough sources
        echo "ERROR: Insufficient source support. Content must have:" >&2
        echo "       - At least 1 path (local file), OR" >&2
        echo "       - At least 2 URLs, OR" >&2  
        echo "       - At least 1 URL + 1 path" >&2
        echo "       Current: $url_count URLs, $path_count paths" >&2
        return 1
    fi
}

# Helper function to add field with list support to content item
_add_field_to_content_item() {
    local field_name="$1"
    local field_value="$2"
    local is_first_field="$3"  # whether this is the first field (goes on same line as -)
    
    if [[ "$field_value" == *"|"* ]]; then
        if [[ "$is_first_field" == "true" ]]; then
            content+="$field_name:"
        else
            content+="
        $field_name:"
        fi
        local value_copy="$field_value"
        while [[ "$value_copy" == *"|"* ]]; do
            local item="${value_copy%%|*}"
            [[ -n "$item" ]] && content+="
          - ${item}"
            value_copy="${value_copy#*|}"
        done
        # Add the last item
        [[ -n "$value_copy" ]] && content+="
          - ${value_copy}"
    else
        if [[ "$is_first_field" == "true" ]]; then
            content+="$field_name: ${field_value}"
        else
            content+="
        $field_name: ${field_value}"
        fi
    fi
}

# Helper function to add sources to content item
_add_sources_to_content_item() {
    # Always use sources array format
    content+="
        source:"
    
    for spec in "${sources[@]}"; do
        local citation="${spec%%|*}"
        local rest="${spec#*|}"
        
        content+="
            - citation: ${citation}"
        
        # Process URLs and paths for this source
        local -a urls=()
        local -a paths=()
        
        while [[ -n "$rest" ]]; do
            local component
            if [[ "$rest" == *"|"* ]]; then
                component="${rest%%|*}"
                rest="${rest#*|}"
            else
                component="$rest"
                rest=""
            fi
            
            if [[ "$component" == url:* ]]; then
                urls+=("${component#url:}")
            elif [[ "$component" == path:* ]]; then
                paths+=("${component#path:}")
            fi
        done
        
        # Add URLs array (only if URLs exist)
        if [[ ${#urls[@]} -gt 0 ]]; then
            content+="
              url:"
            for url in "${urls[@]}"; do
                content+="
                - ${url}"
            done
        fi
        
        # Add paths array (only if paths exist)
        if [[ ${#paths[@]} -gt 0 ]]; then
            content+="
              path:"
            for path in "${paths[@]}"; do
                content+="
                - ${path}"
            done
        fi
    done
}

# Helper function to add field with list support to new content item
_add_field_to_new_content_item() {
    local field_name="$1"
    local field_value="$2"
    local is_first_field="$3"  # whether this is the first field (goes on same line as -)
    
    if [[ "$field_value" == *"|"* ]]; then
        if [[ "$is_first_field" == "true" ]]; then
            new_content+="$field_name:"
        else
            new_content+="
        $field_name:"
        fi
        local value_copy="$field_value"
        while [[ "$value_copy" == *"|"* ]]; do
            local item="${value_copy%%|*}"
            [[ -n "$item" ]] && new_content+="
          - ${item}"
            value_copy="${value_copy#*|}"
        done
        # Add the last item
        [[ -n "$value_copy" ]] && new_content+="
          - ${value_copy}"
    else
        if [[ "$is_first_field" == "true" ]]; then
            new_content+="$field_name: ${field_value}"
        else
            new_content+="
        $field_name: ${field_value}"
        fi
    fi
}

# Helper function to add sources to new content item
_add_sources_to_new_content_item() {
    # Always use sources array format
    new_content+="
        source:"
    
    for spec in "${sources[@]}"; do
        local citation="${spec%%|*}"
        local rest="${spec#*|}"
        
        new_content+="
            - citation: ${citation}"
        
        # Process URLs and paths for this source
        local -a urls=()
        local -a paths=()
        
        while [[ -n "$rest" ]]; do
            local component
            if [[ "$rest" == *"|"* ]]; then
                component="${rest%%|*}"
                rest="${rest#*|}"
            else
                component="$rest"
                rest=""
            fi
            
            if [[ "$component" == url:* ]]; then
                urls+=("${component#url:}")
            elif [[ "$component" == path:* ]]; then
                paths+=("${component#path:}")
            fi
        done
        
        # Add URLs array (only if URLs exist)
        if [[ ${#urls[@]} -gt 0 ]]; then
            new_content+="
              url:"
            for url in "${urls[@]}"; do
                new_content+="
                - ${url}"
            done
        fi
        
        # Add paths array (only if paths exist)
        if [[ ${#paths[@]} -gt 0 ]]; then
            new_content+="
              path:"
            for path in "${paths[@]}"; do
                new_content+="
                - ${path}"
            done
        fi
    done
}

# Generate underscore-separated label from ISO, date, and title
_generate_label() {
    local iso="$1" date="$2" title="$3"
    local clean_iso=$(echo "$iso" | /usr/bin/tr '[:upper:]' '[:lower:]')
    local clean_date=$(echo "$date" | /usr/bin/tr '[:upper:]' '[:lower:]' | /usr/bin/sed 's/[^a-z0-9]/_/g; s/__*/_/g; s/^_\|_$//g')
    local clean_title=$(echo "$title" | /usr/bin/tr '[:upper:]' '[:lower:]' | /usr/bin/sed 's/[^a-z0-9]/_/g; s/__*/_/g; s/^_\|_$//g')
    echo "${clean_iso}_${clean_date}_${clean_title}"
}

# Validate date format
_validate_date_format() {
    local date="$1"
    
    # Single dates: YYYY, YYYY-MM, YYYY-MM-DD, YYYY-Q#
    if [[ "$date" =~ ^[0-9]{4}$ ]] || \
       [[ "$date" =~ ^[0-9]{4}-[0-9]{2}$ ]] || \
       [[ "$date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || \
       [[ "$date" =~ ^[0-9]{4}-Q[1-4]$ ]]; then
        return 0
    fi
    
    # Periods: "YYYY to YYYY" format variations
    if [[ "$date" =~ ^[0-9]{4}[[:space:]]to[[:space:]][0-9]{4}$ ]] || \
       [[ "$date" =~ ^[0-9]{4}-[0-9]{2}[[:space:]]to[[:space:]][0-9]{4}-[0-9]{2}$ ]] || \
       [[ "$date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]]to[[:space:]][0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || \
       [[ "$date" =~ ^[0-9]{4}-Q[1-4][[:space:]]to[[:space:]][0-9]{4}-Q[1-4]$ ]]; then
        return 0
    fi
    
    return 1
}

# If script is executed directly (not sourced), run yamlevent function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    yamlevent "$@"
fi